Міністерство освіти і науки України
Харківський національний університет радіоелектроніки


Кафедра Програмної інженерії



Звіт
З практичної роботи №1
з дисципліни «Скриптові мови програмування»









Виконав									Перевірив
ст.гр ПЗПІ-23-3 Чуваєв А.О.						ст. в. Сокорчук І.П.







Харків 2025
1. Хід роботи
1.1  Постановка задачі:
     В ході даного практичного заняття потрібно написати Bash скрипт, який друкуватиме на екрані ялинку із двох ярусів гілок, стовбура та шару снігу.
     Обмеження: 
     ‒ Ялинка повинна бути симетричною.
     ‒ Яруси гілок повинні утворювати правильні рівнобедрені трикутники у яких сусідні рядки відрізняються на два символи та складаються почергово
або з символів «*» або з символів «#»
     ‒ Ширина усіх ярусів гілок повинна бути на 2 символи вужча ніж ширина снігу.
     ‒ Висота стовбура та товщина снігу мають бути завжди такі, як у прикладі.
     ‒ Висота ялинки у рядках разом з шаром снігу та ширина шару снігу в символах вказується скрипту в його параметрах при запуску.
     ‒ Параметри скрипта повинні мати додатнє значення.
     ‒ Вказані значення повинні округлятися до потрібних у меншу сторону.
     ‒ Якщо за вказаними при запуску скрипта значеннями зобразити ялинку на екрані неможливо, скрипт повинен вивести у потік помилок сповіщення про неправильне значення аргумента і повернути відповідний результат у батьківський процес.
     ‒ У скрипті потрібно обовʼязково використати такі конструкції:
       	if ... then ... fi  
       while ... do ... done  
       until ... do ... done  
       for ... in .. do ... done  
       for ((...)); do ... done  
     ‒ У скрипті також потрібно використати функцію.  
     ‒ Ім’я скрипта: ~/{імʼя-облікового-запису}-task1
     ‒ Приклад виклику скрипта: ~/pzpiz-26-7-shukhevych-roman-task1 16 11
     ‒ Файл скрипта повинен бути виконуваним файлом для усіх користувачів системи.
     ‒ Право редагувати файл скрипта повинен мати лише власник скрипта.
1.2  Створення Bash скрипту
1.2.1 Створення файлу та надання відповідних прав
     Для створення Bash скрипту потрібно авторизуватися на віддаленому сервері, та створити файл. Для цього скористаймося командою touch та передамо в якості аргумента назву файлу, що нам потрібно зробити, в результаті отримаємо таку команду:
       touch pzpi-23-3-chuvaiev-artem-task1
	Після цього, одразу ж змінемо права доступу до файлу, скориставшись командою chmod:
       chmod 755 pzpi-23-3-chuvaiev-artem-task1
       chmod +x pzpi-23-3-chuvaiev-artem-task1
1.2.2 Написання Bash скрипту
1.2.2.1 Обробка аргументів
     Для забезпечення правильної обробки аргументів, варто повернутися до постановки задачі, і побачити, що має бути 2 вхідних аргумента, що аргументи скрипта мають бути додатними, і також, щоб задовільнити умовам задачі, висота повинна бути більше за 7, а ширина повинна дорівнювати висоті – 1.
     Також для забезпечення коректної роботи скрипта, варто звернути увагу на умову з округленням у нижчу сторону. Отже, можемо зробити висновок, що якщо висота непарна, то її потрібно зменшити на 1, а також якщо ширина парна, то її теж треба зменшити на 1, а лише потім робити перевірку валідності параметрів.
     З урахуванням всіх вище зазначених особливостей, маємо ось такий код:
       01: #!/bin/bash
       02: if [ $# -eq 0 ]; then
       03:   echo "No arguments" >&2
       04:   exit 6
       05: fi
       06: 
       07: heightTree=$1
       08: widthSnow=$2
       09: 
       10: if (( heightTree % 2 != 0 )); then
       11:     heightTree=$(($heightTree - 1))
       12: fi
       13: 
       14: if (( $widthSnow % 2 == 0 )); then
       15:     widthSnow=$(($widthSnow - 1))
       16: fi
       17: 
       18: checkInput() {
       19:   if [[ $1 -le 0 || $2 -le 0 ]]; then
       20:     echo "Error: Height and width must be positive values" >&2
       21:     return 1
       22:   fi
       23:   if [ $1 -le 7 ] || [ $2 -ne $(($1 - 1)) ] ; then
       24:     echo "Impossible to build a tree." >&2
       25:     return 2
       26:   fi
       27: 
       28:   return 0
       29: }
       30: 
       31: error_message=$(checkInput "$heightTree" "$widthSnow" 2>&1)
       32: exit_code=$?
       33: 
       34: if (( exit_code != 0 )); then
       35:   echo "$error_message" >&2
       36:   exit "$exit_code"
       37: fi
     В цьому коді, ми, за допомогою функції checkInput(), перевіряємо аргументи, що прийшли до функції, і якщо вони не відповідають умовам, то виводимо результат у потік виведення помилок, та повертаємо відповідний код помилки, далі, в основному коді, перевіряємо результат останнього виклику, за допомогою оператору $?, і якщо він не дорівнює нулю, то завершуємо роботу скрипту з відповідною помилкою.
1.2.2.2 Відображення ярусів ялинки
     В якості кожного з ярусів ялинки, мають виступати правильні рівнобедрені трикутники, де символи мають чередуватись поступово, також ширина усіх ярусів має бути на 2 менша за ширину снігу. Отже маємо наступний код:
       39: heightPerSection=$((($heightTree - 3) / 2 + 1))
       40: symbol='*'
       41: currentAmountSymbols=1
       42: 
       43: for (( i=0; i < 2; i++ )); do
       44:     row=""
       45:     for (( j = 0; j < $heightPerSection; j++ )); do
       46:         spaces=""
       47:         symbols=""
       48:         
       49:         spaceCount=$((($widthSnow - $currentAmountSymbols) / 2))
       50:         
       51:         for (( sp = 0; sp < $spaceCount; sp++)); do
       52:             spaces+=" " 
       53:         done
       54:         
       55:         for ((sy = 0; sy < $currentAmountSymbols; sy++)); do
       56:             symbols="$symbols$symbol" 
       57:         done
       58:         
       59:         row="$spaces$symbols"
       60:         echo "$row"
       61:         
       62:         currentAmountSymbols=$(($currentAmountSymbols + 2))
       63:         
       64:         if [[ $symbol == "#" ]]; then
       65:             symbol='*'
       66:         else 
       67:             symbol='#'
       68:         fi
       69:     done
       70:     currentAmountSymbols=3
       71:     heightPerSection=$((heightPerSection - 1))
       72: done
	
     В цьому коді ми задаємо початкові зміні, heighPerSection відповідає за висоту на кожен ярус ялинки, і розраховується формулою (висота – 3 )  /  2  + 1, далі символ, що спочатку має бути зірочкою, а також кількість символів, що буде потрібна для коректного відображення ялинки. Далі ми проходимось 2 рази в C-подібному циклі, в якому малюємо кожен ярус. На кожному етапі циклу, ми прораховуємо кількість пробілів, які нам варто вивести, кількість символів, та також після кожного надрукованого ряду, ми перевіряємо який саме символ нам треба виводити. Також варто згадати те, що після друку секції, ми скидуємо значення всіх змінних, щоб мати змогу швидко перемалювати наступну секцію.
1.2.2.3 Побудова стовбуру
     Для побудови стовбуру, ми можемо звернутись до постановки задачі і зробити висновок, що він має бути чітко посередині, бо ялинка має бути симетричною, отже маємо ось такий код:
       74: spaceCount=$((($widthSnow - 3) / 2))
       75: counter=0
       76: spaces=""
       77: 
       78: while [ $counter -ne $spaceCount ]; do
       79:     spaces="$spaces " 
       80:     counter=$((counter + 1))
       81: done
       82: 
       83: for i in {0,1}; do
       84:     echo "$spaces###"
       85: done
     
     В цьому коді ми оголошуємо декілька зміних, перша це кількість пробілів що треба надрукувати, далі ітератор, що буде використано у while циклі, а також змінну spaces, що буде зберігати символи пробілів. Після цього за допомогою першого циклу ми ініціалізуємо змінну пробілів і додаємо три решітки у якості стовбуру, а в for in циклі ми виводимо двічі наш стовбур.
1.2.2.4  Шар снігу
     Останній пункт виконання скрипту – це друк шару снігу, що було задано на початку за допомогою відповідного аргументу.
       87: counter=0
       88: row=""
       89: star='*'
       90: until [ $counter -eq $(($widthSnow)) ]; do
       91:     row="$row$star"
       92:     counter=$((counter + 1))
       93: done
       94: echo "$row"
     
     В цьому коді ми оголошуємо декілька змінних, counter – це ітератор, row зберігає рядок, який відповідає шару снігу, і символ зірки, що буде додаватись до вже існуючого ряду. Далі у until циклі ми просто додаємо у кінець символи, щоб створити шар снігу правильної довжини.
1.3  Тестування програми
     Перевіримо коректність роботи програми. 
Спочатку перевіримо, що станеться, якщо не передати аргументи
       pzpi-23-3-chuvaiev-artem@vps52766:~$ ./pzpi-23-3-chuvaiev-artem-task1
       No arguments
       
Як і очікується, скрипт повернув помилку.
Далі перевіримо, як поведе себе скрипт з невалідними даними:
       pzpi-23-3-chuvaiev-artem@vps52766:~$ ./pzpi-23-3-chuvaiev-artem-task1 1 2
       Error: Height and width must be positive values
Як і очікується, скрипт повернув помилку.
І тепер перевіримо роботу скрипта з валідними даними:
       
       pzpi-23-3-chuvaiev-artem@vps52766:~$ ./pzpi-23-3-chuvaiev-artem-task1 8 7
          *
         ###
        *****
         ###
        *****
         ###
         ###
       *******
     Як бачимо, скрипт повернув симетричну ялинку, яруси якої є рівнобедреними трикутниками, ширина ярусів не є більшою за ширину снігу - 2, а також символи в ялинці чергуються.
       
     Висновок
      В ході цього практичного заняття, було набуто навичок написання Bash скриптів, було засвоєно основний синтаксис, основні конструкції, роботу з потоками виведення, операторами циклів, а також умовними операторами. А також було реалізовано відображення ялинки відносно всіх поставлених вимог. 


ДОДАТОК А: ПОВНИЙ КОД ПРОГРАМИ
       01: #!/bin/bash
       02: if [ $# -eq 0 ]; then
       03:   echo "No arguments" >&2
       04:   exit 6
       05: fi
       06: 
       07: heightTree=$1
       08: widthSnow=$2
       09: 
       10: if (( heightTree % 2 != 0 )); then
       11:     heightTree=$(($heightTree - 1))
       12: fi
       13: 
       14: if (( $widthSnow % 2 == 0 )); then
       15:     widthSnow=$(($widthSnow - 1))
       16: fi
       17: 
       18: checkInput() {
       19:   if [[ $1 -le 0 || $2 -le 0 ]]; then
       20:     echo "Error: Height and width must be positive values" >&2
       21:     return 1
       22:   fi
       23:   if [ $1 -le 7 ] || [ $2 -ne $(($1 - 1)) ] ; then
       24:     echo "Impossible to build a tree." >&2
       25:     return 2
       26:   fi
       27: 
       28:   return 0
       29: }
       30: 
       31: error_message=$(checkInput "$heightTree" "$widthSnow" 2>&1)
       32: exit_code=$?
       33: 
       34: if (( exit_code != 0 )); then
       35:   echo "$error_message" >&2
       36:   exit "$exit_code"
       37: fi
       38: 
       39: heightPerSection=$((($heightTree - 3) / 2 + 1))
       40: symbol='*'
       41: currentAmountSymbols=1
       42: 
       43: for (( i=0; i < 2; i++ )); do
       44:     row=""
       45:     for (( j = 0; j < $heightPerSection; j++ )); do
       46:         spaces=""
       47:         symbols=""
       48:         
       49:         spaceCount=$((($widthSnow - $currentAmountSymbols) / 2))
       50:         
       51:         for (( sp = 0; sp < $spaceCount; sp++)); do
       52:             spaces+=" " 
       53:         done
       54:         
       55:         for ((sy = 0; sy < $currentAmountSymbols; sy++)); do
       56:             symbols="$symbols$symbol" 
       57:         done
       58:         
       59:         row="$spaces$symbols"
       60:         echo "$row"
       61:         
       62:         currentAmountSymbols=$(($currentAmountSymbols + 2))
       63:         
       64:         if [[ $symbol == "#" ]]; then
       65:             symbol='*'
       66:         else 
       67:             symbol='#'
       68:         fi
       69:     done
       70:     currentAmountSymbols=3
       71:     heightPerSection=$((heightPerSection - 1))
       72: done
       73: 
       74: spaceCount=$((($widthSnow - 3) / 2))
       75: counter=0
       76: spaces=""
       77: 
       78: while [ $counter -ne $spaceCount ]; do
       79:     spaces="$spaces " 
       80:     counter=$((counter + 1))
       81: done
       82: 
       83: for i in {0,1}; do
       84:     echo "$spaces###"
       85: done
       86: 
       87: counter=0
       88: row=""
       89: star='*'
       90: until [ $counter -eq $(($widthSnow)) ]; do
       91:     row="$row$star"
       92:     counter=$((counter + 1))
       93: done
       94: echo "$row"
     24
     
     
